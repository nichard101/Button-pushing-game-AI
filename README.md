# 10 PUSHING BUTTONS

Lydia Acton & Nick Brown

## Manually Calculated Solutions (clicking buttons and hoping for the best)

These puzzle solutions were created through trial and error by subjecting ourselves to the puzzle and repeating it until we stumbled upon a solution we liked.

**Puzzle 8: 3 moves**

- Blue Star, Red Star, Blue Diamond

**Puzzle 17: 10 moves**

- Blue Circle, Yellow Square, Red Triangle, Green Triangle, Green Diamond, Orange Diamond, Purple Square, Yellow Square, Purple Star, Green Triangle

**Puzzle 24: 6 moves**

- Yellow Diamond, Blue Cross, Purple Star, Purple Diamond, Green Diamond, Purple Star

## The Program

To run the program, type the following commands into your IDE:

    javac *.java
    java Solver

This will prompt you to enter the name of a puzzle file that exists inside the Puzzles folder. If the file contains a valid puzzle, a minimum solution pattern for the puzzle will be printed.

A valid puzzle file consists of lines of text where each line describes a button in the following format: *\[colour\] \[shape\] \[state\]*, where the state is either true (the button is able to be pressed) or false (the button is unable to be pressed until it is toggled by another button). The program supports buttons with any colour and any shape imaginable, as long as each consist of only a single word. For example, **puzzle8.txt** looks like this:

    blue star true
    red circle true
    blue circle false
    blue diamond false
    yellow circle false
    yellow star false
    red diamond false
    red star false

Alternatively, you can use the command:

    java Solver -default

to automatically search for the solutions to puzzles 8, 17, and 24.

## Minimum Puzzle Solutions (generated by The Machine)

These solutions were generated by our program through a breadth-first search. This search method guarantees that the first solution found is a solution that has the minimum possible number of moves.

**Puzzle 8: 3 moves**

- Red Circle, Red Diamond, Blue Circle

**Puzzle 17: 10 moves**

- Blue Circle, Yellow Square, Purple Square, Yellow Square, Red Triangle, Orange Circle, Purple Star, Orange Diamond, Orange Circle, Green Diamond

**Puzzle 24: 6 moves**

- Purple Diamond, Yellow Star, Blue Cross, Yellow Diamond, Green Diamond, Yellow Star

## Program Overview (and a bit of dev history on the side)

The main algorithm in the program is a simple loop over the length of a "to-do list" of puzzle objects. Each puzzle object contains an ArrayList of buttons, in essence describing the puzzle's state. The program iterates through the list of puzzles to check and, for each puzzle in the list, generates a series of all possible permutations of the puzzle (ie. it creates a new puzzle copy for each button that can possibly be pushed). For each permutation, if it doesn't already exist on a separate list of "seen" puzzles, it is added to the to-do pile. Each permutation also receives a record of which button was pressed, which is added to another internal list unique to each Puzzle object. Finally, the main puzzle of the operation is added to the "seen" list.

The above loop, while taking a few days of redrafting to fully iron out, is relatively simple. Thus, the main hurdle of development was creating a system that would, with 100% consistency, be able to identify two puzzle "states" that are equal to each other. This is to make sure that any generated puzzle permutations can always be identified as copies of puzzles on the "seen" list with complete accuracy. Without this mechanism, the program will examine the exact same puzzle scenarios over and over again, wasting precious resources and time.

In order to ensure that two equal puzzles could be compared to each other, within the Puzzle Class we created custom hashCode() and equals() methods. These methods allowed us to implement HashSets into the main program, which can never store duplicate objects. Through testing we found that different object arrays with the same values, ostensibly "duplicates", would be seen as unique in the eyes of the HashSet where we did not want them to be. However, clones of Strings seemed to be a lot more reliably caught than clones of arrays, so we devised an algorithm within the Puzzle class to compare each String within the array of buttons, as opposed to the arrays themselves. This also allowed us to match two puzzles with the same state of buttons but different button press histories.

The "to-do" list is an ArrayList rather than a HashSet because, while a HashSet will only allow unique entries it does not support strict ordering. This means that a for-each loop would be required, which is insufficient when the loop modifies the contents of the set it is looping through. Additionally, the use of ordering in an ArrayList allowed us to guarantee two properties: if puzzle A appears in the list before puzzle B, then puzzle A must be from either an earlier or equal "generation" to that of puzzle B, and if puzzle B appears in the list after puzzle A then puzzle B must be from either a later or equal "generation" to that of puzzle A. In essence, puzzles in the list can be ordered based on the number of moves that each puzzle has gone through. This is useful because the first solved puzzle found in the list when iterating upwards from zero will never contain more moves than any solved puzzles that appear later in the list - the first solved puzzle to be found always contains the minimum number of moves. The "seen" list, on the other hand, can be a HashSet because the ordering doesn't matter much when considering only puzzles that have already been calculated and tossed to the side. 

While we managed to create a replacement equals() method for the Puzzle Class, we could do the same with the hashCode() method. Our implementation appears to be inable to generate sufficiently unique hash codes for each unique puzzle object. This means that we cannot solely rely on the inbuilt HashSet capabilities. Instead, we had to implement an extra method that calls a Puzzle's equals() method before adding it to the "seen" list. This results in identical functionality to the HashSet, but is obviously not as clean.

Once a solved puzzle is located, the number of moves required is calculated based on the size of the list of all button presses that Puzzle object has sustained. This number and the list of moves itself (arguably the most important part) are then summarily printed before the program closes.

## Testing

Most of the testing involved with this program was related to experiments on the equals() methods of various objects. Through experimentation we discovered that two String objects containing the same character sequence will always equal each other regardless of whether either object has been modified in some way prior. This is in contrast to String arrays and ArrayLists, which do not necessarily equal each other despite sharing the exact same contents. This showed us that our Puzzle equals() method must rely on comparing the Strings inside of our button arrays, rather than simply comparing the arrays themselves, and this ended up being crucial in the development of our program.

Additionally, to be sure that the program was in fact generating a minimum solution to each puzzle, we tasked ourselves with attempting to solve them by hand in as few moves as possible. Throughout our attempts, we were never able to produce solutions that were better than what the program would output - at best we could only produce equal results. Granted, we are not puzzle experts by any means, but we feel that this is a very good proof of our program's suitability for this etude. Just to be safe, we also ran the program through an additional set of puzzles aside from 8/17/24, which all gave similarly satisfactory results.